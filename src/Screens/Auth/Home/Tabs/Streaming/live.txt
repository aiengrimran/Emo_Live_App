import React, {useRef, useEffect, useState, useContext} from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  Platform,
} from 'react-native';
import appStyles from '../../../../../styles/styles';
import {
  createAgoraRtcEngine,
  ChannelProfileType,
  ClientRoleType,
  IRtcEngine,
  AudienceLatencyLevelType,
  RtcSurfaceView,
  RtcConnection,
  IRtcEngineEventHandler,
  ConnectionStateType,
  ConnectionChangedReasonType,
  VideoSourceType,
} from 'react-native-agora';
import Context from '../../../../../Context/Context';
import envVar from '../../../../../config/envVar';
import {setModalInfo} from '../../../../../store/slice/podcastSlice';
import {ChatClient} from 'react-native-agora-chat';
import {setHostLeftPodcast} from '../../../../../store/slice/podcastSlice';
import {useSelector, useDispatch} from 'react-redux';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import {colors} from '../../../../../styles/colors';
import axiosInstance from '../../../../../Api/axiosConfig';

export default function LiveStreaming({navigation}) {
  const chatClient = ChatClient.getInstance();
  const agoraEngineRef = useRef<IRtcEngine>(); // IRtcEngine instance
  const {userAuthInfo} = useContext(Context);
  const {user} = userAuthInfo;
  const dispatch = useDispatch();

  const [isJoined, setIsJoined] = useState(false);
  const [onLive, setOnLive] = useState(false);
  const {hostId, stream, streamListeners, rtcTokenRenewed, roomId} =
    useSelector((state: any) => state.streaming);
  const eventHandler = useRef<IRtcEngineEventHandler>(); // Implement callback functions
  const {guests} = useSelector((state: any) => state.streaming);

  useEffect(() => {
    setupVideoSDKEngine(); // Initialize Agora engine
    return () => {
      agoraEngineRef.current?.unregisterEventHandler(eventHandler.current!);
      agoraEngineRef.current?.release();
    };
  }, []);

  const setupVideoSDKEngine = async () => {
    try {
      console.log('Initializing Agora engine');
      agoraEngineRef.current = createAgoraRtcEngine();
      const agoraEngine = agoraEngineRef.current;
      eventHandler.current = {
        onJoinChannelSuccess: (_connection: RtcConnection, elapsed: number) => {
          console.log('Successfully joined channel: ' + elapsed);
          if (stream.host === user.id) {
            createUserChatRoom();
          }
          setIsJoined(true);
        },
        onUserJoined: (_connection: RtcConnection, uid: number) => {
          console.log('Remote user ' + uid + ' joined');
          getUserInfoFromAPI(uid);
        },
        onUserOffline: (_connection: RtcConnection, uid: number) => {
          if (uid === hostId) {
            hostEndedStream();
          }
          console.log('Remote user ' + uid + ' left the channel');
        },
        onConnectionStateChanged: (
          _connection: RtcConnection,
          state: ConnectionStateType,
          reason: ConnectionChangedReasonType,
        ) => {
          console.log('Connection state changed:', state, _connection);
          console.log('Reason for state change:', reason);
          handleConnection(reason);
        },
      };

      agoraEngine.registerEventHandler(eventHandler.current);
      agoraEngine.initialize({
        appId: envVar.AGORA_APP_ID,
      });
    } catch (e) {
      console.error('Error initializing Agora engine:', e);
    }
  };

  const createUserChatRoom = async () => {
    try {
      const chatRoom = await chatClient.roomManager.createChatRoom(
        'Stream',
        'Hi',
        'welcome',
        [],
        guests,
      );
      const roomId = chatRoom.roomId;
      saveChatRoomId(roomId);
      userJoinChatRoom(roomId);
      console.log('Chat room created with ID:', roomId);
    } catch (error) {
      console.error('Error creating chat room:', error);
    }
  };

  const userJoinChatRoom = async (roomId: string) => {
    try {
      await chatClient.roomManager.joinChatRoom(roomId);
    } catch (error) {
      console.error('Error joining chat room:', error);
    }
  };

  const hostEndedStream = async () => {
    try {
      dispatch(setHostLeftPodcast(true));
      dispatch(setModalInfo({modal: true, isHost: false}));
    } catch (error) {
      console.error('Error ending stream:', error);
    }
  };

  const handleConnection = (state: number) => {
    switch (state) {
      case 1:
      case 9:
        setOnLive(true);
        break;
      default:
        break;
    }
  };

  const saveChatRoomId = async (roomId: string) => {
    try {
      const url = `${envVar.LOCAL_URL}stream/save-roomId`;
      const data = {
        chatRoomId: roomId,
        id: stream.id,
      };
      const res = await axiosInstance.post(url, data);
      console.log('Chat room ID saved:', res.data);
    } catch (error) {
      console.error('Error saving chat room ID:', error);
    }
  };

  const getUserInfoFromAPI = async (id: string | number) => {
    try {
      const idsArray = [id];
      const data = {users: idsArray};
      console.log('Request Data:', data);

      const url = 'users-info';
      const res = await axiosInstance.post(url, data);
      console.log('API Response:', res.data);

      if (res.data.users.length > 0) {
        const updatedUsers = [...streamListeners];
        updatedUsers.unshift(res.data.users[0]);
        updatedUsers.pop();
        dispatch(setStreamListeners(updatedUsers));
      }
    } catch (error) {
      console.error(
        'API Error:',
        error.response ? error.response.data : error.message,
      );
    }
  };

  const getGridLayout = () => {
    if (guests <= 1) return {rows: 1, cols: 1};
    if (guests <= 4) return {rows: 2, cols: 2};
    if (guests <= 6) return {rows: 3, cols: 2};
    return {rows: Math.ceil(guests / 2), cols: 2};
  };

  const {rows, cols} = getGridLayout();

  const renderHost = ({item, index}) => (
    <View style={styles.hostView}>
      {item.id ? (
        <RtcSurfaceView
          canvas={{
            uid: item.id,
            sourceType: VideoSourceType.VideoSourceRemote,
          }}
          style={styles.videoView}
        />
      ) : (
        <Text>Waiting for user {index} to join</Text>
      )}
    </View>
  );

  return (
    <View style={styles.container}>
      <View style={{marginTop: Platform.OS === 'ios' ? 60 : 30}}>
        <Text style={styles.heading}>Start Live</Text>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={{alignSelf: 'flex-end', marginTop: -22}}>
          <Icon name="close" size={25} color={colors.complimentary} />
        </TouchableOpacity>
      </View>
      <View style={{flexDirection: 'row', marginTop: 30}}>
        <View style={styles.localView}>
          {onLive ? (
            <RtcSurfaceView canvas={{uid: user.id}} />
          ) : (
            <Text>Connecting to server...</Text>
          )}
        </View>
        <View style={styles.gridContainer}>
          <FlatList
            data={streamListeners}
            renderItem={renderHost}
            keyExtractor={item => item.id.toString()}
            numColumns={cols}
            contentContainerStyle={styles.grid}
          />
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.LG,
    padding: 10,
  },
  heading: {
    ...appStyles.headline,
    color: colors.complimentary,
    textAlign: 'center',
    alignSelf: 'center',
  },
  localView: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#e0e0e0',
    borderWidth: 1,
    borderColor: '#ccc',
  },
  gridContainer: {
    flex: 1,
  },
  grid: {
    flexGrow: 1,
  },
  hostView: {
    flex: 1,
    aspectRatio: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    borderWidth: 1,
    borderColor: '#ccc',
    margin: 5,
  },
  videoView: {
    flex: 1,
    aspectRatio: 1,
  },
});
